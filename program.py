import tkinter as tk
from tkinter import Canvas, Frame
from pulp_solver import *


# Function to handle the drag-and-drop functionality
def on_drag_start(event, task):
    widget = event.widget
    widget.startX = event.x
    widget.startY = event.y
    widget.task = task


def on_drag_motion(event):
    widget = event.widget
    deltax = event.x - widget.startX
    deltay = event.y - widget.startY
    widget.move(widget.task, deltax, deltay)
    widget.startX = event.x
    widget.startY = event.y


def transform_to_schedule(tasks):
    schedule = {}
    for task in tasks.values():
        for t in task:
            resource_id = t['resource_id']
            if resource_id not in schedule:
                schedule[resource_id] = []
            schedule[resource_id].append(t)
    return schedule


def create_gantt_chart(schedule):
    root = tk.Tk()
    root.title("Gantt Chart")

    canvas_width = 800
    canvas_height = 1000

    canvas = tk.Canvas(root, width=canvas_width, height=canvas_height, bg='white')
    canvas.pack()

    y = 50  # Initial y position

    for resource_id, tasks in schedule.items():
        # Draw horizontal line as a divider between resource timelines
        canvas.create_line(0, y, canvas_width, y, fill='black')

        # Label for the resource
        canvas.create_text(10, y - 20, text=f"Resource: {resource_id}", anchor=tk.W, fill='black')

        # Separation box for each resource's tasks
        start_x = float('inf')
        end_x = float('-inf')
        start_y = y

        for task in tasks:
            start_time = task['start_time'] * 50
            end_time = task['end_time'] * 50

            # Update the box dimensions
            if start_time < start_x:
                start_x = start_time
            if end_time > end_x:
                end_x = end_time

            # Draw rectangles representing tasks on each resource's timeline
            canvas.create_rectangle(start_time, y, end_time, y + 40, fill=task['color'], outline='black')
            canvas.create_text(start_time + 2, y + 20, text=task['job_name'], anchor=tk.W, fill='black')

            y += 50  # Move to the next line for the next task

        # Enclose tasks of each resource within a box
        canvas.create_rectangle(start_x, start_y, end_x, y + 40, outline='black')

        y += 50  # Space between different resources

    root.mainloop()


def run_algorithm_and_update_gui():
    # Run your production planning algorithm here and get the schedule
    # Replace this with the actual function call and schedule retrieval based on your algorithm
    schedule = get_production_schedule()

    create_gantt_chart(transform_to_schedule(schedule))


def get_production_schedule():
    # Replace this function with the call to your production planning algorithm
    # Return the schedule generated by your algorithm
    jobs = {
        1: {'duration': 3, 'resource': 'A', 'level': 1, 'name': 'Job_A'},
        2: {'duration': 2, 'resource': 'B', 'level': 2, 'name': 'Job_B'},
        3: {'duration': 4, 'resource': 'B', 'level': 2, 'name': 'Job_C'},
        4: {'duration': 2, 'resource': 'C', 'level': 2, 'name': 'Job_D'},
        5: {'duration': 5, 'resource': 'A', 'level': 3, 'name': 'Job_E'},
    }
    # Job dependencies (lower level needs to finish before higher level begins)
    dependencies = [
        (1, 2),
        (1, 3),
        (1, 4),
        (2, 5),
        (3, 5),
        (4, 5),
    ]

    schedule = pulp_solve(jobs, dependencies)
    tasks_by_resource = {}
    for slot, tasks in schedule.items():
        for task in tasks:
            resource_id = task['resource_id']
            if resource_id not in tasks_by_resource:
                tasks_by_resource[resource_id] = []
            tasks_by_resource[resource_id].append(task)

    # Ensure non-overlapping schedules for tasks sharing the same resource
    for resource, tasks in tasks_by_resource.items():
        tasks.sort(key=lambda x: x['start_time'])  # Sort tasks by start time
        for i in range(len(tasks) - 1):
            current_task = tasks[i]
            next_task = tasks[i + 1]
            if current_task['end_time'] > next_task['start_time']:
                # Resolve conflict by adjusting the start time of next task
                new_start_time = current_task['end_time']
                tasks[i + 1]['start_time'] = new_start_time
                tasks[i + 1]['end_time'] = new_start_time + (tasks[i + 1]['end_time'] - tasks[i + 1]['start_time'])

    # Updated schedule after resolving conflicts
    updated_schedule = {}
    for slot, tasks in schedule.items():
        updated_schedule[slot] = tasks

    print(schedule)
    return schedule


# Running the application

if __name__ == "__main__":
    run_algorithm_and_update_gui()
